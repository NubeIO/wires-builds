export interface Error {
    /** Code is the machine-readable error code. */
    readonly code: 'internal error' | 'not found' | 'conflict' | 'invalid' | 'unprocessable entity' | 'empty value' | 'unavailable' | 'forbidden' | 'too many requests' | 'unauthorized' | 'method not allowed';
    /** Message is a human-readable message. */
    readonly message: string;
}
export interface Routes {
    authorizations?: string;
    buckets?: string;
    dashboards?: string;
    external?: {
        statusFeed?: string;
    };
    variables?: string;
    me?: string;
    flags?: string;
    orgs?: string;
    query?: {
        self?: string;
        ast?: string;
        analyze?: string;
        suggestions?: string;
    };
    setup?: string;
    signin?: string;
    signout?: string;
    sources?: string;
    system?: {
        metrics?: string;
        debug?: string;
        health?: string;
    };
    tasks?: string;
    telegrafs?: string;
    users?: string;
    write?: string;
}
export interface IsOnboarding {
    /** True means that the influxdb instance has NOT had initial setup; false means that the database has been setup. */
    allowed?: boolean;
}
export interface OnboardingRequest {
    username: string;
    password?: string;
    org: string;
    bucket: string;
    retentionPeriodHrs?: number;
}
export interface OnboardingResponse {
    user?: User;
    org?: Organization;
    bucket?: Bucket;
    auth?: Authorization;
}
export interface User {
    readonly id?: string;
    oauthID?: string;
    name: string;
    /** If inactive the user is inactive. */
    status?: 'active' | 'inactive';
    readonly links?: {
        self?: string;
    };
}
export interface Organization {
    readonly links?: {
        self?: Link;
        members?: Link;
        owners?: Link;
        labels?: Link;
        secrets?: Link;
        buckets?: Link;
        tasks?: Link;
        dashboards?: Link;
    };
    readonly id?: string;
    name: string;
    description?: string;
    readonly createdAt?: string;
    readonly updatedAt?: string;
    /** If inactive the organization is inactive. */
    status?: 'active' | 'inactive';
}
/**
 * URI of resource.
 */
export declare type Link = string;
export interface Bucket {
    readonly links?: {
        /** URL to retrieve labels for this bucket */
        labels?: Link;
        /** URL to retrieve members that can read this bucket */
        members?: Link;
        /** URL to retrieve parent organization for this bucket */
        org?: Link;
        /** URL to retrieve owners that can read and write to this bucket. */
        owners?: Link;
        /** URL for this bucket */
        self?: Link;
        /** URL to write line protocol for this bucket */
        write?: Link;
    };
    readonly id?: string;
    readonly type?: 'user' | 'system';
    name: string;
    description?: string;
    orgID?: string;
    rp?: string;
    readonly createdAt?: string;
    readonly updatedAt?: string;
    retentionRules: RetentionRules;
    labels?: Labels;
}
/**
 * Rules to expire or retain data.  No rules means data never expires.
 */
export declare type RetentionRules = RetentionRule[];
export interface RetentionRule {
    type: 'expire';
    /** Duration in seconds for how long data will be kept in the database. */
    everySeconds: number;
}
export declare type Labels = Label[];
export interface Label {
    readonly id?: string;
    readonly orgID?: string;
    name?: string;
    /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
    properties?: any;
}
export declare type Authorization = AuthorizationUpdateRequest & {
    readonly createdAt?: string;
    readonly updatedAt?: string;
    /** ID of org that authorization is scoped to. */
    orgID?: string;
    /** List of permissions for an auth.  An auth must have at least one Permission. */
    permissions?: Permission[];
    readonly id?: string;
    /** Passed via the Authorization Header and Token Authentication type. */
    readonly token?: string;
    /** ID of user that created and owns the token. */
    readonly userID?: string;
    /** Name of user that created and owns the token. */
    readonly user?: string;
    /** Name of the org token is scoped to. */
    readonly org?: string;
    readonly links?: {
        readonly self?: Link;
        readonly user?: Link;
    };
};
export interface AuthorizationUpdateRequest {
    /** If inactive the token is inactive and requests using the token will be rejected. */
    status?: 'active' | 'inactive';
    /** A description of the token. */
    description?: string;
}
export interface Permission {
    action: 'read' | 'write';
    resource: Resource;
}
export interface Resource {
    type: 'authorizations' | 'buckets' | 'dashboards' | 'orgs' | 'sources' | 'tasks' | 'telegrafs' | 'users' | 'variables' | 'scrapers' | 'secrets' | 'labels' | 'views' | 'documents' | 'notificationRules' | 'notificationEndpoints' | 'checks' | 'dbrp';
    /** If ID is set that is a permission for a specific resource. if it is not set it is a permission for all resources of that resource type. */
    id?: string;
    /** Optional name of the resource if the resource has a name field. */
    name?: string;
    /** If orgID is set that is a permission for all resources owned my that org. if it is not set it is a permission for all resources of that resource type. */
    orgID?: string;
    /** Optional name of the organization of the organization with orgID. */
    org?: string;
}
export interface Documents {
    documents?: DocumentListEntry[];
}
export interface DocumentListEntry {
    readonly id: string;
    meta: DocumentMeta;
    labels?: Labels;
    readonly links?: {
        /** The document URL. */
        self?: Link;
    };
}
export interface DocumentMeta {
    name: string;
    type?: string;
    templateID?: string;
    description?: string;
    version: string;
    readonly createdAt?: string;
    readonly updatedAt?: string;
}
export interface DocumentCreate {
    meta: DocumentMeta;
    content: any;
    /** The organization Name. Specify either `orgID` or `org`. */
    org?: string;
    /** The organization Name. Specify either `orgID` or `org`. */
    orgID?: string;
    /** An array of label IDs to be added as labels to the document. */
    labels?: string[];
}
export interface Document {
    readonly id: string;
    meta: DocumentMeta;
    content: any;
    labels?: Labels;
    readonly links?: {
        /** The document URL. */
        self?: Link;
    };
}
export interface DocumentUpdate {
    meta?: DocumentMeta;
    content?: any;
}
export interface LabelsResponse {
    labels?: Labels;
    links?: Links;
}
export interface Links {
    next?: Link;
    self: Link;
    prev?: Link;
}
export interface LabelMapping {
    labelID?: string;
}
export interface LabelResponse {
    label?: Label;
    links?: Links;
}
export interface DBRPs {
    notificationEndpoints?: DBRP[];
    links?: Links;
}
export interface DBRP {
    /** the mapping identifier */
    readonly id?: string;
    /** the organization ID that owns this mapping. */
    orgID: string;
    /** the organization that owns this mapping. */
    org: string;
    /** the bucket ID used as target for the translation. */
    bucketID: string;
    /** InfluxDB v1 database */
    database: string;
    /** InfluxDB v1 retention policy */
    retention_policy: string;
    /** Specify if this mapping represents the default retention policy for the database specificed. */
    default?: boolean;
    links?: Links;
}
export interface DBRPUpdate {
    /** InfluxDB v1 database */
    database?: string;
    /** InfluxDB v1 retention policy */
    retention_policy?: string;
    default?: boolean;
    links?: Links;
}
export interface TelegrafPlugins {
    version?: string;
    os?: string;
    plugins?: TelegrafPlugin[];
}
export interface TelegrafPlugin {
    type?: string;
    name?: string;
    description?: string;
    config?: string;
}
export interface Telegrafs {
    configurations?: Telegraf[];
}
export declare type Telegraf = TelegrafRequest & {
    readonly id?: string;
    readonly links?: {
        self?: Link;
        labels?: Link;
        members?: Link;
        owners?: Link;
    };
    readonly labels?: Labels;
};
export interface TelegrafRequest {
    name?: string;
    description?: string;
    metadata?: {
        buckets?: string[];
    };
    config?: string;
    orgID?: string;
}
export interface ResourceMembers {
    links?: {
        self?: string;
    };
    users?: ResourceMember[];
}
export declare type ResourceMember = User & {
    role?: 'member';
};
export interface AddResourceMemberRequestBody {
    id: string;
    name?: string;
}
export interface ResourceOwners {
    links?: {
        self?: string;
    };
    users?: ResourceOwner[];
}
export declare type ResourceOwner = User & {
    role?: 'owner';
};
export interface ScraperTargetResponses {
    configurations?: ScraperTargetResponse[];
}
export declare type ScraperTargetResponse = ScraperTargetRequest & {
    readonly id?: string;
    /** The organization name. */
    org?: string;
    /** The bucket name. */
    bucket?: string;
    readonly links?: {
        self?: Link;
        members?: Link;
        owners?: Link;
        bucket?: Link;
        organization?: Link;
    };
};
export interface ScraperTargetRequest {
    /** The name of the scraper target. */
    name?: string;
    /** The type of the metrics to be parsed. */
    type?: 'prometheus';
    /** The URL of the metrics endpoint. */
    url?: string;
    /** The organization ID. */
    orgID?: string;
    /** The ID of the bucket to write to. */
    bucketID?: string;
}
export interface Variables {
    variables?: Variable[];
}
export interface Variable {
    readonly links?: {
        self?: string;
        org?: string;
        labels?: string;
    };
    readonly id?: string;
    orgID: string;
    name: string;
    description?: string;
    selected?: string[];
    labels?: Labels;
    arguments: VariableProperties;
    createdAt?: string;
    updatedAt?: string;
}
export declare type VariableProperties = QueryVariableProperties | ConstantVariableProperties | MapVariableProperties;
export interface QueryVariableProperties {
    type?: 'query';
    values?: {
        query?: string;
        language?: string;
    };
}
export interface ConstantVariableProperties {
    type?: 'constant';
    values?: string[];
}
export interface MapVariableProperties {
    type?: 'map';
    values?: any;
}
export interface LineProtocolError {
    /** Code is the machine-readable error code. */
    readonly code: 'internal error' | 'not found' | 'conflict' | 'invalid' | 'empty value' | 'unavailable';
    /** Message is a human-readable message. */
    readonly message: string;
    /** Op describes the logical code operation during error. Useful for debugging. */
    readonly op: string;
    /** Err is a stack of errors that occurred during processing of the request. Useful for debugging. */
    readonly err: string;
    /** First line within sent body containing malformed data */
    readonly line?: number;
}
export interface LineProtocolLengthError {
    /** Code is the machine-readable error code. */
    readonly code: 'invalid';
    /** Message is a human-readable message. */
    readonly message: string;
    /** Max length in bytes for a body of line-protocol. */
    readonly maxLength: number;
}
/**
 * The delete predicate request.
 */
export interface DeletePredicateRequest {
    /** RFC3339Nano */
    start: string;
    /** RFC3339Nano */
    stop: string;
    /** InfluxQL-like delete statement */
    predicate?: string;
}
export interface Ready {
    status?: 'ready';
    started?: string;
    up?: string;
}
export interface HealthCheck {
    name: string;
    message?: string;
    checks?: HealthCheck[];
    status: 'pass' | 'fail';
    version?: string;
    commit?: string;
}
export interface Sources {
    links?: {
        self?: string;
    };
    sources?: Source[];
}
export interface Source {
    links?: {
        self?: string;
        query?: string;
        health?: string;
        buckets?: string;
    };
    id?: string;
    orgID?: string;
    default?: boolean;
    name?: string;
    type?: 'v1' | 'v2' | 'self';
    url?: string;
    insecureSkipVerify?: boolean;
    telegraf?: string;
    token?: string;
    username?: string;
    password?: string;
    sharedSecret?: string;
    metaUrl?: string;
    defaultRP?: string;
    readonly languages?: Array<'flux' | 'influxql'>;
}
export interface Buckets {
    readonly links?: Links;
    buckets?: Bucket[];
}
export interface LabelCreateRequest {
    orgID: string;
    name?: string;
    /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
    properties?: any;
}
export interface LabelUpdate {
    name?: string;
    /** Key/Value pairs associated with this label. Keys can be removed by sending an update with an empty value. */
    properties?: any;
}
export interface Dashboards {
    links?: Links;
    dashboards?: Dashboard[];
}
export declare type Dashboard = CreateDashboardRequest & {
    links?: {
        self?: Link;
        cells?: Link;
        members?: Link;
        owners?: Link;
        labels?: Link;
        org?: Link;
    };
    readonly id?: string;
    meta?: {
        createdAt?: string;
        updatedAt?: string;
    };
    cells?: Cells;
    labels?: Labels;
};
export interface CreateDashboardRequest {
    /** The ID of the organization that owns the dashboard. */
    orgID: string;
    /** The user-facing name of the dashboard. */
    name: string;
    /** The user-facing description of the dashboard. */
    description?: string;
}
export declare type Cells = Cell[];
export interface Cell {
    id?: string;
    links?: {
        self?: string;
        view?: string;
    };
    x?: number;
    y?: number;
    w?: number;
    h?: number;
    /** The reference to a view from the views API. */
    viewID?: string;
}
export declare type DashboardWithViewProperties = CreateDashboardRequest & {
    links?: {
        self?: Link;
        cells?: Link;
        members?: Link;
        owners?: Link;
        labels?: Link;
        org?: Link;
    };
    readonly id?: string;
    meta?: {
        createdAt?: string;
        updatedAt?: string;
    };
    cells?: CellsWithViewProperties;
    labels?: Labels;
};
export declare type CellsWithViewProperties = CellWithViewProperties[];
export declare type CellWithViewProperties = Cell & {
    name?: string;
    properties?: ViewProperties;
};
export declare type ViewProperties = LinePlusSingleStatProperties | XYViewProperties | SingleStatViewProperties | HistogramViewProperties | GaugeViewProperties | TableViewProperties | MarkdownViewProperties | CheckViewProperties | ScatterViewProperties | HeatmapViewProperties | MosaicViewProperties | BandViewProperties;
export interface LinePlusSingleStatProperties {
    timeFormat?: string;
    type: 'line-plus-single-stat';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    axes: Axes;
    legend: Legend;
    xColumn?: string;
    yColumn?: string;
    shadeBelow?: boolean;
    hoverDimension?: 'auto' | 'x' | 'y' | 'xy';
    position: 'overlaid' | 'stacked';
    prefix: string;
    suffix: string;
    decimalPlaces: DecimalPlaces;
}
export interface DashboardQuery {
    /** The text of the Flux query. */
    text?: string;
    editMode?: QueryEditMode;
    name?: string;
    builderConfig?: BuilderConfig;
}
export declare type QueryEditMode = 'builder' | 'advanced';
export interface BuilderConfig {
    buckets?: string[];
    tags?: BuilderTagsType[];
    functions?: BuilderFunctionsType[];
    aggregateWindow?: {
        period?: string;
        fillValues?: boolean;
    };
}
export interface BuilderTagsType {
    key?: string;
    values?: string[];
    aggregateFunctionType?: BuilderAggregateFunctionType;
}
export declare type BuilderAggregateFunctionType = 'filter' | 'group';
export interface BuilderFunctionsType {
    name?: string;
}
/**
 * Defines an encoding of data value into color space.
 */
export interface DashboardColor {
    /** The unique ID of the view color. */
    id: string;
    /** Type is how the color is used. */
    type: 'min' | 'max' | 'threshold' | 'scale' | 'text' | 'background';
    /** The hex number of the color */
    hex: string;
    /** The user-facing name of the hex color. */
    name: string;
    /** The data value mapped to this color. */
    value: number;
}
/**
 * The viewport for a View's visualizations
 */
export interface Axes {
    x: Axis;
    y: Axis;
}
/**
 * The description of a particular axis for a visualization.
 */
export interface Axis {
    /** The extents of an axis in the form [lower, upper]. Clients determine whether bounds are to be inclusive or exclusive of their limits */
    bounds?: string[];
    /** Label is a description of this Axis */
    label?: string;
    /** Prefix represents a label prefix for formatting axis values. */
    prefix?: string;
    /** Suffix represents a label suffix for formatting axis values. */
    suffix?: string;
    /** Base represents the radix for formatting axis values. */
    base?: '' | '2' | '10';
    scale?: AxisScale;
}
/**
 * Scale is the axis formatting scale. Supported: "log", "linear"
 */
export declare type AxisScale = 'log' | 'linear';
/**
 * Legend define encoding of data into a view's legend
 */
export interface Legend {
    /** The style of the legend. */
    type?: 'static';
    /** orientation is the location of the legend with respect to the view graph */
    orientation?: 'top' | 'bottom' | 'left' | 'right';
}
/**
 * Indicates whether decimal places should be enforced, and how many digits it should show.
 */
export interface DecimalPlaces {
    /** Indicates whether decimal point setting should be enforced */
    isEnforced?: boolean;
    /** The number of digits after decimal to display */
    digits?: number;
}
export interface XYViewProperties {
    timeFormat?: string;
    type: 'xy';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    axes: Axes;
    legend: Legend;
    xColumn?: string;
    yColumn?: string;
    shadeBelow?: boolean;
    hoverDimension?: 'auto' | 'x' | 'y' | 'xy';
    position: 'overlaid' | 'stacked';
    geom: XYGeom;
}
export declare type XYGeom = 'line' | 'step' | 'stacked' | 'bar' | 'monotoneX';
export interface SingleStatViewProperties {
    type: 'single-stat';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    prefix: string;
    tickPrefix: string;
    suffix: string;
    tickSuffix: string;
    legend: Legend;
    decimalPlaces: DecimalPlaces;
}
export interface HistogramViewProperties {
    type: 'histogram';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    xColumn: string;
    fillColumns: string[];
    xDomain: number[];
    xAxisLabel: string;
    position: 'overlaid' | 'stacked';
    binCount: number;
}
export interface GaugeViewProperties {
    type: 'gauge';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    prefix: string;
    tickPrefix: string;
    suffix: string;
    tickSuffix: string;
    legend: Legend;
    decimalPlaces: DecimalPlaces;
}
export interface TableViewProperties {
    type: 'table';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    tableOptions: {
        /** verticalTimeAxis describes the orientation of the table by indicating whether the time axis will be displayed vertically */
        verticalTimeAxis?: boolean;
        sortBy?: RenamableField;
        /** Wrapping describes the text wrapping style to be used in table views */
        wrapping?: 'truncate' | 'wrap' | 'single-line';
        /** fixFirstColumn indicates whether the first column of the table should be locked */
        fixFirstColumn?: boolean;
    };
    /** fieldOptions represent the fields retrieved by the query with customization options */
    fieldOptions: RenamableField[];
    /** timeFormat describes the display format for time values according to moment.js date formatting */
    timeFormat: string;
    decimalPlaces: DecimalPlaces;
}
/**
 * Describes a field that can be renamed and made visible or invisible.
 */
export interface RenamableField {
    /** The calculated name of a field. */
    readonly internalName?: string;
    /** The name that a field is renamed to by the user. */
    displayName?: string;
    /** Indicates whether this field should be visible on the table. */
    visible?: boolean;
}
export interface MarkdownViewProperties {
    type: 'markdown';
    shape: 'chronograf-v2';
    note: string;
}
export interface CheckViewProperties {
    type: 'check';
    shape: 'chronograf-v2';
    checkID: string;
    check?: Check;
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
}
export declare type Check = CheckDiscriminator;
export declare type CheckDiscriminator = (DeadmanCheck & {
    type: string;
}) | (ThresholdCheck & {
    type: string;
}) | (CustomCheck & {
    type: string;
});
export declare type DeadmanCheck = CheckBase & {
    type: 'deadman';
    /** String duration before deadman triggers. */
    timeSince?: string;
    /** String duration for time that a series is considered stale and should not trigger deadman. */
    staleTime?: string;
    /** If only zero values reported since time, trigger an alert */
    reportZero?: boolean;
    level?: CheckStatusLevel;
    /** Check repetition interval. */
    every?: string;
    /** Duration to delay after the schedule, before executing check. */
    offset?: string;
    /** List of tags to write to each status. */
    tags?: Array<{
        key?: string;
        value?: string;
    }>;
    /** The template used to generate and write a status message. */
    statusMessageTemplate?: string;
};
export interface CheckBase {
    readonly id?: string;
    name: string;
    /** The ID of the organization that owns this check. */
    orgID: string;
    /** The ID of creator used to create this check. */
    readonly ownerID?: string;
    readonly createdAt?: string;
    readonly updatedAt?: string;
    query: DashboardQuery;
    status?: TaskStatusType;
    /** An optional description of the check. */
    description?: string;
    /** Timestamp of latest scheduled, completed run, RFC3339. */
    readonly latestCompleted?: string;
    readonly lastRunStatus?: 'failed' | 'success' | 'canceled';
    readonly lastRunError?: string;
    labels?: Labels;
    readonly links?: {
        /** URL for this check */
        self?: Link;
        /** URL to retrieve labels for this check */
        labels?: Link;
        /** URL to retrieve members for this check */
        members?: Link;
        /** URL to retrieve owners for this check */
        owners?: Link;
        /** URL to retrieve flux script for this check */
        query?: Link;
    };
}
export declare type TaskStatusType = 'active' | 'inactive';
/**
 * The state to record if check matches a criteria.
 */
export declare type CheckStatusLevel = 'UNKNOWN' | 'OK' | 'INFO' | 'CRIT' | 'WARN';
export declare type ThresholdCheck = CheckBase & {
    type: 'threshold';
    thresholds?: Threshold[];
    /** Check repetition interval. */
    every?: string;
    /** Duration to delay after the schedule, before executing check. */
    offset?: string;
    /** List of tags to write to each status. */
    tags?: Array<{
        key?: string;
        value?: string;
    }>;
    /** The template used to generate and write a status message. */
    statusMessageTemplate?: string;
};
export declare type Threshold = (GreaterThreshold & {
    type: string;
}) | (LesserThreshold & {
    type: string;
}) | (RangeThreshold & {
    type: string;
});
export declare type GreaterThreshold = ThresholdBase & {
    type: 'greater';
    value: number;
};
export interface ThresholdBase {
    level?: CheckStatusLevel;
    /** If true, only alert if all values meet threshold. */
    allValues?: boolean;
}
export declare type LesserThreshold = ThresholdBase & {
    type: 'lesser';
    value: number;
};
export declare type RangeThreshold = ThresholdBase & {
    type: 'range';
    min: number;
    max: number;
    within: boolean;
};
export declare type CustomCheck = CheckBase & {
    type: 'custom';
};
export interface ScatterViewProperties {
    timeFormat?: string;
    type: 'scatter';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: string[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    xColumn: string;
    yColumn: string;
    fillColumns: string[];
    symbolColumns: string[];
    xDomain: number[];
    yDomain: number[];
    xAxisLabel: string;
    yAxisLabel: string;
    xPrefix: string;
    xSuffix: string;
    yPrefix: string;
    ySuffix: string;
}
export interface HeatmapViewProperties {
    timeFormat?: string;
    type: 'heatmap';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: string[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    xColumn: string;
    yColumn: string;
    xDomain: number[];
    yDomain: number[];
    xAxisLabel: string;
    yAxisLabel: string;
    xPrefix: string;
    xSuffix: string;
    yPrefix: string;
    ySuffix: string;
    binSize: number;
}
export interface MosaicViewProperties {
    timeFormat?: string;
    type: 'mosaic';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: string[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    xColumn: string;
    ySeriesColumns: string[];
    fillColumns: string[];
    xDomain: number[];
    yDomain: number[];
    xAxisLabel: string;
    yAxisLabel: string;
    xPrefix: string;
    xSuffix: string;
    yPrefix: string;
    ySuffix: string;
}
export interface BandViewProperties {
    timeFormat?: string;
    type: 'band';
    queries: DashboardQuery[];
    /** Colors define color encoding of data into a visualization */
    colors: DashboardColor[];
    shape: 'chronograf-v2';
    note: string;
    /** If true, will display note when empty */
    showNoteWhenEmpty: boolean;
    axes: Axes;
    legend: Legend;
    xColumn?: string;
    yColumn?: string;
    upperColumn?: string;
    mainColumn?: string;
    lowerColumn?: string;
    hoverDimension?: 'auto' | 'x' | 'y' | 'xy';
    geom: XYGeom;
}
export interface CreateCell {
    name?: string;
    x?: number;
    y?: number;
    w?: number;
    h?: number;
    /** Makes a copy of the provided view. */
    usingView?: string;
}
export interface CellUpdate {
    x?: number;
    y?: number;
    w?: number;
    h?: number;
}
export interface View {
    readonly links?: {
        self?: string;
    };
    readonly id?: string;
    name: string;
    properties: ViewProperties;
}
/**
 * Flux query to be analyzed.
 */
export interface LanguageRequest {
    /** Flux query script to be analyzed */
    query: string;
}
/**
 * Contains the AST for the supplied Flux query
 */
export interface ASTResponse {
    ast?: Package;
}
/**
 * Represents a complete package source tree.
 */
export interface Package {
    type?: NodeType;
    /** Package import path */
    path?: string;
    /** Package name */
    package?: string;
    /** Package files */
    files?: File[];
}
/**
 * Type of AST node
 */
export declare type NodeType = string;
/**
 * Represents a source from a single file
 */
export interface File {
    type?: NodeType;
    /** The name of the file. */
    name?: string;
    package?: PackageClause;
    /** A list of package imports */
    imports?: ImportDeclaration[];
    /** List of Flux statements */
    body?: Statement[];
}
/**
 * Defines a package identifier
 */
export interface PackageClause {
    type?: NodeType;
    name?: Identifier;
}
/**
 * A valid Flux identifier
 */
export interface Identifier {
    type?: NodeType;
    name?: string;
}
/**
 * Declares a package import
 */
export interface ImportDeclaration {
    type?: NodeType;
    as?: Identifier;
    path?: StringLiteral;
}
/**
 * Expressions begin and end with double quote marks
 */
export interface StringLiteral {
    type?: NodeType;
    value?: string;
}
export declare type Statement = BadStatement | VariableAssignment | MemberAssignment | ExpressionStatement | ReturnStatement | OptionStatement | BuiltinStatement | TestStatement;
/**
 * A placeholder for statements for which no correct statement nodes can be created
 */
export interface BadStatement {
    type?: NodeType;
    /** Raw source text */
    text?: string;
}
/**
 * Represents the declaration of a variable
 */
export interface VariableAssignment {
    type?: NodeType;
    id?: Identifier;
    init?: Expression;
}
export declare type Expression = ArrayExpression | FunctionExpression | BinaryExpression | CallExpression | ConditionalExpression | LogicalExpression | MemberExpression | IndexExpression | ObjectExpression | ParenExpression | PipeExpression | UnaryExpression | BooleanLiteral | DateTimeLiteral | DurationLiteral | FloatLiteral | IntegerLiteral | PipeLiteral | RegexpLiteral | StringLiteral | UnsignedIntegerLiteral | Identifier;
/**
 * Used to create and directly specify the elements of an array object
 */
export interface ArrayExpression {
    type?: NodeType;
    /** Elements of the array */
    elements?: Expression[];
}
/**
 * Function expression
 */
export interface FunctionExpression {
    type?: NodeType;
    /** Function parameters */
    params?: Property[];
    body?: Node;
}
/**
 * The value associated with a key
 */
export interface Property {
    type?: NodeType;
    key?: PropertyKey;
    value?: Expression;
}
export declare type PropertyKey = Identifier | StringLiteral;
export declare type Node = Expression | Block;
/**
 * A set of statements
 */
export interface Block {
    type?: NodeType;
    /** Block body */
    body?: Statement[];
}
/**
 * uses binary operators to act on two operands in an expression
 */
export interface BinaryExpression {
    type?: NodeType;
    operator?: string;
    left?: Expression;
    right?: Expression;
}
/**
 * Represents a function call
 */
export interface CallExpression {
    type?: NodeType;
    callee?: Expression;
    /** Function arguments */
    arguments?: Expression[];
}
/**
 * Selects one of two expressions, `Alternate` or `Consequent`, depending on a third boolean expression, `Test`
 */
export interface ConditionalExpression {
    type?: NodeType;
    test?: Expression;
    alternate?: Expression;
    consequent?: Expression;
}
/**
 * Represents the rule conditions that collectively evaluate to either true or false
 */
export interface LogicalExpression {
    type?: NodeType;
    operator?: string;
    left?: Expression;
    right?: Expression;
}
/**
 * Represents accessing a property of an object
 */
export interface MemberExpression {
    type?: NodeType;
    object?: Expression;
    property?: PropertyKey;
}
/**
 * Represents indexing into an array
 */
export interface IndexExpression {
    type?: NodeType;
    array?: Expression;
    index?: Expression;
}
/**
 * Allows the declaration of an anonymous object within a declaration
 */
export interface ObjectExpression {
    type?: NodeType;
    /** Object properties */
    properties?: Property[];
}
/**
 * Represents an expression wrapped in parenthesis
 */
export interface ParenExpression {
    type?: NodeType;
    expression?: Expression;
}
/**
 * Call expression with pipe argument
 */
export interface PipeExpression {
    type?: NodeType;
    argument?: Expression;
    call?: CallExpression;
}
/**
 * Uses operators to act on a single operand in an expression
 */
export interface UnaryExpression {
    type?: NodeType;
    operator?: string;
    argument?: Expression;
}
/**
 * Represents boolean values
 */
export interface BooleanLiteral {
    type?: NodeType;
    value?: boolean;
}
/**
 * Represents an instant in time with nanosecond precision using the syntax of golang's RFC3339 Nanosecond variant
 */
export interface DateTimeLiteral {
    type?: NodeType;
    value?: string;
}
/**
 * Represents the elapsed time between two instants as an int64 nanosecond count with syntax of golang's time.Duration
 */
export interface DurationLiteral {
    type?: NodeType;
    /** Duration values */
    values?: Duration[];
}
/**
 * A pair consisting of length of time and the unit of time measured. It is the atomic unit from which all duration literals are composed.
 */
export interface Duration {
    type?: NodeType;
    magnitude?: number;
    unit?: string;
}
/**
 * Represents floating point numbers according to the double representations defined by the IEEE-754-1985
 */
export interface FloatLiteral {
    type?: NodeType;
    value?: number;
}
/**
 * Represents integer numbers
 */
export interface IntegerLiteral {
    type?: NodeType;
    value?: string;
}
/**
 * Represents a specialized literal value, indicating the left hand value of a pipe expression
 */
export interface PipeLiteral {
    type?: NodeType;
}
/**
 * Expressions begin and end with `/` and are regular expressions with syntax accepted by RE2
 */
export interface RegexpLiteral {
    type?: NodeType;
    value?: string;
}
/**
 * Represents integer numbers
 */
export interface UnsignedIntegerLiteral {
    type?: NodeType;
    value?: string;
}
/**
 * Object property assignment
 */
export interface MemberAssignment {
    type?: NodeType;
    member?: MemberExpression;
    init?: Expression;
}
/**
 * May consist of an expression that does not return a value and is executed solely for its side-effects
 */
export interface ExpressionStatement {
    type?: NodeType;
    expression?: Expression;
}
/**
 * Defines an expression to return
 */
export interface ReturnStatement {
    type?: NodeType;
    argument?: Expression;
}
/**
 * A single variable declaration
 */
export interface OptionStatement {
    type?: NodeType;
    assignment?: VariableAssignment | MemberAssignment;
}
/**
 * Declares a builtin identifier and its type
 */
export interface BuiltinStatement {
    type?: NodeType;
    id?: Identifier;
}
/**
 * Declares a Flux test case
 */
export interface TestStatement {
    type?: NodeType;
    assignment?: VariableAssignment;
}
export interface FluxSuggestions {
    funcs?: FluxSuggestion[];
}
export interface FluxSuggestion {
    name?: string;
    params?: any;
}
export interface Authorizations {
    readonly links?: Links;
    authorizations?: Authorization[];
}
/**
 * Query influx using the Flux language
 */
export interface Query {
    extern?: File;
    /** Query script to execute. */
    query: string;
    /** The type of query. Must be "flux". */
    type?: 'flux';
    dialect?: Dialect;
    /** Specifies the time that should be reported as "now" in the query. Default is the server's now time. */
    now?: string;
}
/**
 * Dialect are options to change the default CSV output format; https://www.w3.org/TR/2015/REC-tabular-metadata-20151217/#dialect-descriptions
 */
export interface Dialect {
    /** If true, the results will contain a header row */
    header?: boolean;
    /** Separator between cells; the default is , */
    delimiter?: string;
    /** Https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#columns */
    annotations?: Array<'group' | 'datatype' | 'default'>;
    /** Character prefixed to comment strings */
    commentPrefix?: string;
    /** Format of timestamps */
    dateTimeFormat?: 'RFC3339' | 'RFC3339Nano';
}
export interface AnalyzeQueryResponse {
    errors?: Array<{
        line?: number;
        column?: number;
        character?: number;
        message?: string;
    }>;
}
/**
 * Query influx using the InfluxQL language
 */
export interface InfluxQLQuery {
    /** InfluxQL query execute. */
    query: string;
    /** The type of query. Must be "influxql". */
    type?: 'influxql';
    /** Bucket is to be used instead of the database and retention policy specified in the InfluxQL query. */
    bucket?: string;
}
export interface PostBucketRequest {
    orgID: string;
    name: string;
    description?: string;
    rp?: string;
    retentionRules: RetentionRules;
}
export interface Organizations {
    links?: Links;
    orgs?: Organization[];
}
export declare type SecretKeysResponse = SecretKeys & {
    readonly links?: {
        self?: string;
        org?: string;
    };
};
export interface SecretKeys {
    secrets?: string[];
}
export declare type Secrets = any;
export interface Stack {
    id?: string;
    orgID?: string;
    readonly createdAt?: string;
    events?: Array<{
        eventType?: string;
        name?: string;
        description?: string;
        sources?: string[];
        resources?: Array<{
            apiVersion?: string;
            resourceID?: string;
            kind?: TemplateKind;
            templateMetaName?: string;
            associations?: Array<{
                kind?: TemplateKind;
                metaName?: string;
            }>;
            links?: {
                self?: string;
            };
        }>;
        urls?: string[];
        readonly updatedAt?: string;
    }>;
}
export declare type TemplateKind = 'Bucket' | 'Check' | 'CheckDeadman' | 'CheckThreshold' | 'Dashboard' | 'Label' | 'NotificationEndpoint' | 'NotificationEndpointHTTP' | 'NotificationEndpointPagerDuty' | 'NotificationEndpointSlack' | 'NotificationRule' | 'Task' | 'Telegraf' | 'Variable';
export interface TemplateApply {
    dryRun?: boolean;
    orgID?: string;
    stackID?: string;
    template?: {
        contentType?: string;
        sources?: string[];
        contents?: Template;
    };
    templates?: Array<{
        contentType?: string;
        sources?: string[];
        contents?: Template;
    }>;
    envRefs?: any;
    secrets?: any;
    remotes?: Array<{
        url: string;
        contentType?: string;
    }>;
    actions?: Array<{
        action?: 'skipKind';
        properties?: {
            kind: TemplateKind;
        };
    } | {
        action?: 'skipResource';
        properties?: {
            kind: TemplateKind;
            resourceTemplateName: string;
        };
    }>;
}
export declare type Template = Array<{
    apiVersion?: string;
    kind?: TemplateKind;
    meta?: {
        name?: string;
    };
    spec?: any;
}>;
export interface TemplateSummary {
    sources?: string[];
    stackID?: string;
    summary?: {
        buckets?: Array<{
            id?: string;
            orgID?: string;
            kind?: TemplateKind;
            templateMetaName?: string;
            name?: string;
            description?: string;
            retentionPeriod?: number;
            labelAssociations?: TemplateSummaryLabel[];
            envReferences?: TemplateEnvReferences;
        }>;
        checks?: Array<CheckDiscriminator & {
            kind?: TemplateKind;
            templateMetaName?: string;
            labelAssociations?: TemplateSummaryLabel[];
            envReferences?: TemplateEnvReferences;
        }>;
        dashboards?: Array<{
            id?: string;
            orgID?: string;
            kind?: TemplateKind;
            templateMetaName?: string;
            name?: string;
            description?: string;
            labelAssociations?: TemplateSummaryLabel[];
            charts?: TemplateChart[];
            envReferences?: TemplateEnvReferences;
        }>;
        labels?: TemplateSummaryLabel[];
        labelMappings?: Array<{
            status?: string;
            resourceTemplateMetaName?: string;
            resourceName?: string;
            resourceID?: string;
            resourceType?: string;
            labelTemplateMetaName?: string;
            labelName?: string;
            labelID?: string;
        }>;
        missingEnvRefs?: string[];
        missingSecrets?: string[];
        notificationEndpoints?: Array<NotificationEndpointDiscrimator & {
            kind?: TemplateKind;
            templateMetaName?: string;
            labelAssociations?: TemplateSummaryLabel[];
            envReferences?: TemplateEnvReferences;
        }>;
        notificationRules?: Array<{
            kind?: TemplateKind;
            templateMetaName?: string;
            name?: string;
            description?: string;
            endpointTemplateMetaName?: string;
            endpointID?: string;
            endpointType?: string;
            every?: string;
            offset?: string;
            messageTemplate?: string;
            status?: string;
            statusRules?: Array<{
                currentLevel?: string;
                previousLevel?: string;
            }>;
            tagRules?: Array<{
                key?: string;
                value?: string;
                operator?: string;
            }>;
            labelAssociations?: TemplateSummaryLabel[];
            envReferences?: TemplateEnvReferences;
        }>;
        tasks?: Array<{
            kind?: TemplateKind;
            templateMetaName?: string;
            id?: string;
            name?: string;
            cron?: string;
            description?: string;
            every?: string;
            offset?: string;
            query?: string;
            status?: string;
            envReferences?: TemplateEnvReferences;
        }>;
        telegrafConfigs?: Array<TelegrafRequest & {
            kind?: TemplateKind;
            templateMetaName?: string;
            labelAssociations?: TemplateSummaryLabel[];
            envReferences?: TemplateEnvReferences;
        }>;
        variables?: Array<{
            kind?: TemplateKind;
            templateMetaName?: string;
            id?: string;
            orgID?: string;
            name?: string;
            description?: string;
            arguments?: VariableProperties;
            labelAssociations?: TemplateSummaryLabel[];
            envReferences?: TemplateEnvReferences;
        }>;
    };
    diff?: {
        buckets?: Array<{
            kind?: TemplateKind;
            stateStatus?: string;
            id?: string;
            templateMetaName?: string;
            new?: {
                name?: string;
                description?: string;
                retentionRules?: RetentionRules;
            };
            old?: {
                name?: string;
                description?: string;
                retentionRules?: RetentionRules;
            };
        }>;
        checks?: Array<{
            kind?: TemplateKind;
            stateStatus?: string;
            id?: string;
            templateMetaName?: string;
            new?: CheckDiscriminator;
            old?: CheckDiscriminator;
        }>;
        dashboards?: Array<{
            stateStatus?: string;
            id?: string;
            kind?: TemplateKind;
            templateMetaName?: string;
            new?: {
                name?: string;
                description?: string;
                charts?: TemplateChart[];
            };
            old?: {
                name?: string;
                description?: string;
                charts?: TemplateChart[];
            };
        }>;
        labels?: Array<{
            stateStatus?: string;
            kind?: TemplateKind;
            id?: string;
            templateMetaName?: string;
            new?: {
                name?: string;
                color?: string;
                description?: string;
            };
            old?: {
                name?: string;
                color?: string;
                description?: string;
            };
        }>;
        labelMappings?: Array<{
            status?: string;
            resourceType?: string;
            resourceID?: string;
            resourceTemplateMetaName?: string;
            resourceName?: string;
            labelID?: string;
            labelTemplateMetaName?: string;
            labelName?: string;
        }>;
        notificationEndpoints?: Array<{
            kind?: TemplateKind;
            stateStatus?: string;
            id?: string;
            templateMetaName?: string;
            new?: NotificationEndpointDiscrimator;
            old?: NotificationEndpointDiscrimator;
        }>;
        notificationRules?: Array<{
            kind?: TemplateKind;
            stateStatus?: string;
            id?: string;
            templateMetaName?: string;
            new?: {
                name?: string;
                description?: string;
                endpointName?: string;
                endpointID?: string;
                endpointType?: string;
                every?: string;
                offset?: string;
                messageTemplate?: string;
                status?: string;
                statusRules?: Array<{
                    currentLevel?: string;
                    previousLevel?: string;
                }>;
                tagRules?: Array<{
                    key?: string;
                    value?: string;
                    operator?: string;
                }>;
            };
            old?: {
                name?: string;
                description?: string;
                endpointName?: string;
                endpointID?: string;
                endpointType?: string;
                every?: string;
                offset?: string;
                messageTemplate?: string;
                status?: string;
                statusRules?: Array<{
                    currentLevel?: string;
                    previousLevel?: string;
                }>;
                tagRules?: Array<{
                    key?: string;
                    value?: string;
                    operator?: string;
                }>;
            };
        }>;
        tasks?: Array<{
            kind?: TemplateKind;
            stateStatus?: string;
            id?: string;
            templateMetaName?: string;
            new?: {
                name?: string;
                cron?: string;
                description?: string;
                every?: string;
                offset?: string;
                query?: string;
                status?: string;
            };
            old?: {
                name?: string;
                cron?: string;
                description?: string;
                every?: string;
                offset?: string;
                query?: string;
                status?: string;
            };
        }>;
        telegrafConfigs?: Array<{
            kind?: TemplateKind;
            stateStatus?: string;
            id?: string;
            templateMetaName?: string;
            new?: TelegrafRequest;
            old?: TelegrafRequest;
        }>;
        variables?: Array<{
            kind?: TemplateKind;
            stateStatus?: string;
            id?: string;
            templateMetaName?: string;
            new?: {
                name?: string;
                description?: string;
                args?: VariableProperties;
            };
            old?: {
                name?: string;
                description?: string;
                args?: VariableProperties;
            };
        }>;
    };
    errors?: Array<{
        kind?: TemplateKind;
        reason?: string;
        fields?: string[];
        indexes?: number[];
    }>;
}
export interface TemplateSummaryLabel {
    id?: string;
    orgID?: string;
    kind?: TemplateKind;
    templateMetaName?: string;
    name?: string;
    properties?: {
        color?: string;
        description?: string;
    };
    envReferences?: TemplateEnvReferences;
}
export declare type TemplateEnvReferences = Array<{
    /** Field the environment reference corresponds too */
    resourceField: string;
    /** Key identified as environment reference and is the key identified in the template */
    envRefKey: string;
    /** Value provided to fulfill reference */
    value?: string | number | number | boolean;
    /** Default value that will be provided for the reference when no value is provided */
    defaultValue?: string | number | number | boolean;
}>;
export interface TemplateChart {
    xPos?: number;
    yPos?: number;
    height?: number;
    width?: number;
    properties?: ViewProperties;
}
export declare type NotificationEndpointDiscrimator = (SlackNotificationEndpoint & {
    type: string;
}) | (PagerDutyNotificationEndpoint & {
    type: string;
}) | (HTTPNotificationEndpoint & {
    type: string;
}) | (TelegramNotificationEndpoint & {
    type: string;
});
export declare type SlackNotificationEndpoint = NotificationEndpointBase & {
    /** Specifies the URL of the Slack endpoint. Specify either `URL` or `Token`. */
    url?: string;
    /** Specifies the API token string. Specify either `URL` or `Token`. */
    token?: string;
};
export interface NotificationEndpointBase {
    id?: string;
    orgID?: string;
    userID?: string;
    readonly createdAt?: string;
    readonly updatedAt?: string;
    /** An optional description of the notification endpoint. */
    description?: string;
    name: string;
    /** The status of the endpoint. */
    status?: 'active' | 'inactive';
    labels?: Labels;
    readonly links?: {
        /** URL for this endpoint. */
        self?: Link;
        /** URL to retrieve labels for this endpoint. */
        labels?: Link;
        /** URL to retrieve members for this endpoint. */
        members?: Link;
        /** URL to retrieve owners for this endpoint. */
        owners?: Link;
    };
    type: NotificationEndpointType;
}
export declare type NotificationEndpointType = 'slack' | 'pagerduty' | 'http' | 'telegram';
export declare type PagerDutyNotificationEndpoint = NotificationEndpointBase & {
    clientURL?: string;
    routingKey: string;
};
export declare type HTTPNotificationEndpoint = NotificationEndpointBase & {
    url: string;
    username?: string;
    password?: string;
    token?: string;
    method: 'POST' | 'GET' | 'PUT';
    authMethod: 'none' | 'basic' | 'bearer';
    contentTemplate?: string;
    /** Customized headers. */
    headers?: any;
};
export declare type TelegramNotificationEndpoint = NotificationEndpointBase & {
    /** Specifies the Telegram bot token. See https://core.telegram.org/bots#creating-a-new-bot . */
    token: string;
    /** ID of the telegram channel, a chat_id in https://core.telegram.org/bots/api#sendmessage . */
    channel: string;
};
export interface TemplateExport {
    stackID?: string;
    orgIDs?: Array<{
        orgID?: string;
        resourceFilters?: {
            byLabel?: string[];
            byResourceKind?: TemplateKind[];
        };
    }>;
    resources?: {
        id: string;
        kind: TemplateKind;
        name?: string;
    };
}
export interface Tasks {
    readonly links?: Links;
    tasks?: Task[];
}
export interface Task {
    readonly id: string;
    /** The type of task, this can be used for filtering tasks on list actions. */
    type?: string;
    /** The ID of the organization that owns this Task. */
    orgID: string;
    /** The name of the organization that owns this Task. */
    org?: string;
    /** The name of the task. */
    name: string;
    /** An optional description of the task. */
    description?: string;
    status?: TaskStatusType;
    labels?: Labels;
    /** The ID of the authorization used when this task communicates with the query engine. */
    authorizationID?: string;
    /** The Flux script to run for this task. */
    flux: string;
    /** A simple task repetition schedule; parsed from Flux. */
    every?: string;
    /** A task repetition schedule in the form '* * * * * *'; parsed from Flux. */
    cron?: string;
    /** Duration to delay after the schedule, before executing the task; parsed from flux, if set to zero it will remove this option and use 0 as the default. */
    offset?: string;
    /** Timestamp of latest scheduled, completed run, RFC3339. */
    readonly latestCompleted?: string;
    readonly lastRunStatus?: 'failed' | 'success' | 'canceled';
    readonly lastRunError?: string;
    readonly createdAt?: string;
    readonly updatedAt?: string;
    readonly links?: {
        self?: Link;
        owners?: Link;
        members?: Link;
        runs?: Link;
        logs?: Link;
        labels?: Link;
    };
}
export interface TaskCreateRequest {
    /** The ID of the organization that owns this Task. */
    orgID?: string;
    /** The name of the organization that owns this Task. */
    org?: string;
    status?: TaskStatusType;
    /** The Flux script to run for this task. */
    flux: string;
    /** An optional description of the task. */
    description?: string;
}
export interface TaskUpdateRequest {
    status?: TaskStatusType;
    /** The Flux script to run for this task. */
    flux?: string;
    /** Override the 'name' option in the flux script. */
    name?: string;
    /** Override the 'every' option in the flux script. */
    every?: string;
    /** Override the 'cron' option in the flux script. */
    cron?: string;
    /** Override the 'offset' option in the flux script. */
    offset?: string;
    /** An optional description of the task. */
    description?: string;
}
export interface Runs {
    links?: Links;
    runs?: Run[];
}
export interface Run {
    readonly id?: string;
    readonly taskID?: string;
    readonly status?: 'scheduled' | 'started' | 'failed' | 'success' | 'canceled';
    /** Time used for run's "now" option, RFC3339. */
    scheduledFor?: string;
    /** An array of logs associated with the run. */
    readonly log?: Array<{
        runID?: string;
        time?: string;
        message?: string;
    }>;
    /** Time run started executing, RFC3339Nano. */
    readonly startedAt?: string;
    /** Time run finished executing, RFC3339Nano. */
    readonly finishedAt?: string;
    /** Time run was manually requested, RFC3339Nano. */
    readonly requestedAt?: string;
    readonly links?: {
        self?: string;
        task?: string;
        retry?: string;
    };
}
export interface RunManually {
    /** Time used for run's "now" option, RFC3339.  Default is the server's now time. */
    scheduledFor?: string;
}
export interface Logs {
    readonly events?: LogEvent[];
}
export interface LogEvent {
    /** Time event occurred, RFC3339Nano. */
    readonly time?: string;
    /** A description of the event that occurred. */
    readonly message?: string;
}
export declare type Flags = any;
export interface PasswordResetBody {
    password: string;
}
export interface Users {
    links?: {
        self?: string;
    };
    users?: User[];
}
export interface Checks {
    checks?: Check[];
    links?: Links;
}
export declare type PostCheck = CheckDiscriminator;
export interface CheckPatch {
    name?: string;
    description?: string;
    status?: 'active' | 'inactive';
}
export interface NotificationRules {
    notificationRules?: NotificationRule[];
    links?: Links;
}
export declare type NotificationRule = NotificationRuleDiscriminator;
export declare type NotificationRuleDiscriminator = (SlackNotificationRule & {
    type: string;
}) | (SMTPNotificationRule & {
    type: string;
}) | (PagerDutyNotificationRule & {
    type: string;
}) | (HTTPNotificationRule & {
    type: string;
}) | (TelegramNotificationRule & {
    type: string;
});
export declare type SlackNotificationRule = NotificationRuleBase & SlackNotificationRuleBase;
export interface NotificationRuleBase {
    /** Timestamp of latest scheduled, completed run, RFC3339. */
    readonly latestCompleted?: string;
    readonly lastRunStatus?: 'failed' | 'success' | 'canceled';
    readonly lastRunError?: string;
    readonly id: string;
    endpointID: string;
    /** The ID of the organization that owns this notification rule. */
    orgID: string;
    /** The ID of creator used to create this notification rule. */
    readonly ownerID?: string;
    readonly createdAt?: string;
    readonly updatedAt?: string;
    status: TaskStatusType;
    /** Human-readable name describing the notification rule. */
    name: string;
    sleepUntil?: string;
    /** The notification repetition interval. */
    every?: string;
    /** Duration to delay after the schedule, before executing check. */
    offset?: string;
    runbookLink?: string;
    /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limit cannot be empty. */
    limitEvery?: number;
    /** Don't notify me more than <limit> times every <limitEvery> seconds. If set, limitEvery cannot be empty. */
    limit?: number;
    /** List of tag rules the notification rule attempts to match. */
    tagRules: TagRule[];
    /** An optional description of the notification rule. */
    description?: string;
    /** List of status rules the notification rule attempts to match. */
    statusRules: StatusRule[];
    labels?: Labels;
    readonly links?: {
        /** URL for this endpoint. */
        self?: Link;
        /** URL to retrieve labels for this notification rule. */
        labels?: Link;
        /** URL to retrieve members for this notification rule. */
        members?: Link;
        /** URL to retrieve owners for this notification rule. */
        owners?: Link;
        /** URL to retrieve flux script for this notification rule. */
        query?: Link;
    };
}
export interface TagRule {
    key?: string;
    value?: string;
    operator?: 'equal' | 'notequal' | 'equalregex' | 'notequalregex';
}
export interface StatusRule {
    currentLevel?: RuleStatusLevel;
    previousLevel?: RuleStatusLevel;
    count?: number;
    period?: string;
}
/**
 * The state to record if check matches a criteria.
 */
export declare type RuleStatusLevel = 'UNKNOWN' | 'OK' | 'INFO' | 'CRIT' | 'WARN' | 'ANY';
export interface SlackNotificationRuleBase {
    type: 'slack';
    channel?: string;
    messageTemplate: string;
}
export declare type SMTPNotificationRule = NotificationRuleBase & SMTPNotificationRuleBase;
export interface SMTPNotificationRuleBase {
    type: 'smtp';
    subjectTemplate: string;
    bodyTemplate?: string;
    to: string;
}
export declare type PagerDutyNotificationRule = NotificationRuleBase & PagerDutyNotificationRuleBase;
export interface PagerDutyNotificationRuleBase {
    type: 'pagerduty';
    messageTemplate: string;
}
export declare type HTTPNotificationRule = NotificationRuleBase & HTTPNotificationRuleBase;
export interface HTTPNotificationRuleBase {
    type: 'http';
    url?: string;
}
export declare type TelegramNotificationRule = NotificationRuleBase & TelegramNotificationRuleBase;
export interface TelegramNotificationRuleBase {
    /** The discriminator between other types of notification rules is "telegram". */
    type: 'telegram';
    /** The message template as a flux interpolated string. */
    messageTemplate: string;
    /** Parse mode of the message text per https://core.telegram.org/bots/api#formatting-options . Defaults to "MarkdownV2" . */
    parseMode?: 'MarkdownV2' | 'HTML' | 'Markdown';
    /** Disables preview of web links in the sent messages when "true". Defaults to "false" . */
    disableWebPagePreview?: boolean;
}
export declare type PostNotificationRule = NotificationRuleDiscriminator;
/**
 * Rendered flux that backs the check or notification.
 */
export interface FluxResponse {
    flux?: string;
}
export interface NotificationRuleUpdate {
    name?: string;
    description?: string;
    status?: 'active' | 'inactive';
}
export interface NotificationEndpoints {
    notificationEndpoints?: NotificationEndpoint[];
    links?: Links;
}
export declare type NotificationEndpoint = NotificationEndpointDiscrimator;
export declare type PostNotificationEndpoint = NotificationEndpointDiscrimator;
export interface NotificationEndpointUpdate {
    name?: string;
    description?: string;
    status?: 'active' | 'inactive';
}
//# sourceMappingURL=types.d.ts.map